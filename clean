#!/bin/bash

usage()
{
    echo -e "Removes certain types of files from directory.\n"

    echo    "Usage:"
    echo -e "  clean [options] <dir>...\n"

    echo    "Arguments:"
    echo -e "  dir           name of the directory\n"

    echo    "Options:"
    echo    "  -b            remove ELF files           (default)"
    echo    "  -f            remove without prompt."
    echo    "  -h            display this message."
    echo    "  -n            remove non-executable files."
    echo    "  -s            remove script files."
    echo -e "  -x            remove executable files.\n"

    echo    "Examples:"
    echo    "  clean         remove all ELFs from cwd"
    echo    "  clean -b      remove all ELFS from cwd"
    echo    "  clean -s      remove all scripts from cwd"
    echo    "  clean -x      remove all executable files from cwd"
    echo    "  clean -n      remove all non-executable files from cwd"
    echo    "  clean -xs     remove all executable scripts from cwd"
    echo    "  clean -xb     remove all executable ELFS from cwd"
    echo    "  clean -bs     remove all ELFS and scripts from cwd"
    echo    "  clean -nb     remove non-executable ELFS from cwd"
    echo -e "  clean -ns     remove non-executable scripts from cwd\n"

    echo    "Author:"
    echo -e "  Artyom Danilov\n"
}

# ------------------------------------------------------------------- #
#                          Global variables                           #
# ------------------------------------------------------------------- #

SHORT_OPTS=":bfhnsx"
HELP_MSG="Try: 'clean -h' for more information"

TRASH=()

declare -A FLAGS=(
    [exec]=0     # -x
    [bin]=0      # -b
    [default]=1
    [force]=0    # -f
    [no_exec]=0  # -n
    [script]=0   # -s
)

# ------------------------------------------------------------------- #
#                          Functions                                  #
# ------------------------------------------------------------------- #

# Based on set FLAGS collect files to TRASH array.
collect_trash()
{
    local dir=$1
    if [[ ${FLAGS[bin]} -eq 1 && ${FLAGS[script]} -eq 1 ]]; then
        files_to_trash $dir "script" ""
        files_to_trash $dir "ELF" ""
    elif [[ ${FLAGS[exec]} -eq 1 && ${FLAGS[script]} -eq 1 ]]; then
        files_to_trash $dir "script" "x"
    elif [[ ${FLAGS[exec]} -eq 1 && ${FLAGS[bin]} -eq 1 ]]; then
        files_to_trash $dir "ELF" "x"
    elif [[ ${FLAGS[no_exec]} -eq 1 && ${FLAGS[bin]} -eq 1 ]]; then
        files_to_trash $dir "ELF" "n"
    elif [[ ${FLAGS[no_exec]} -eq 1 && ${FLAGS[script]} -eq 1 ]]; then
        files_to_trash $dir "script" "n"
    elif [[ ${FLAGS[script]} -eq 1 ]]; then
        files_to_trash $dir "script"
    elif [[ ${FLAGS[bin]} -eq 1 ]]; then
        files_to_trash $dir "ELF"
    elif [[ ${FLAGS[exec]} -eq 1 ]]; then
        files_to_trash $dir "" "x"
    elif [[ ${FLAGS[no_exec]} -eq 1 ]]; then
        files_to_trash $dir "" "n"
    fi
}

# Fill TRASH array with files from dir based on their type and mode.
files_to_trash()
{
    local dir=$1
    local type=$2
    local mode=$3  # x - executable, n - not executable

    for file in $(ls $dir); do
        local full_file="$dir/$file"
        if [[ $mode == "x" && -n $type ]]; then
            [[ -x $full_file && $(file $full_file) =~ "$type" ]] && TRASH+=("$full_file")
        elif [[ $mode == "n" && -n $type ]]; then
            [[ ! -x $full_file && $(file $full_file) =~ "$type" ]] && TRASH+=("$full_file")
        elif [[ -n $type ]]; then
            [[ $(file $full_file) =~ "$type" ]] && TRASH+=("$full_file")
        elif [[ $mode == "x" ]]; then
            [[ -x "$full_file" ]] && TRASH+=("$full_file")
        elif [[ $mode == "n" ]]; then
            [[ ! -x "$full_file" ]] && TRASH+=("$full_file")
        fi

    done
}

remove_trash()
{
    if [[ ${FLAGS[force]} -eq 1 ]]; then
        remove_files "${TRASH[@]}"
    else
        for file in "${TRASH[@]}"; do
            echo "'$file'"
        done

        if [[ ${#TRASH[@]} -eq 1 ]]; then
            echo -n "Remove this file? [y/n]: "
        else
            echo -n "Remove these files? [y/n]: "
        fi

        read -re ans
        [[ "$ans" =~ ^[yY]$ ]] && remove_files "${TRASH[@]}"
    fi

}

remove_files()
{
    for file in "$@"; do
        rm "$file"
    done
}

# ------------------------------------------------------------------- #
#                           Parse options                             #
# ------------------------------------------------------------------- #

ARGV=$(getopt -o $SHORT_OPTS -- "$@")

if [[ $? -ne 0 ]]; then
    echo "$HELP_MSG" >&2
    exit 1
fi

eval set -- "$ARGV"

# ------------------------------------------------------------------- #
#                           Toggle options                            #
# ------------------------------------------------------------------- #

while true; do
    case $1 in
        -b)
            FLAGS[default]=0
            FLAGS[bin]=1   ;;
        -f)
            FLAGS[force]=1 ;;
        -h)
            usage
            exit 0 ;;
        -n)
            FLAGS[default]=0
            FLAGS[no_exec]=1 ;;
        -s)
            FLAGS[default]=0
            FLAGS[script]=1 ;;
        -x)
            FLAGS[default]=0
            FLAGS[exec]=1   ;;
        --)
            shift
            break           ;;
    esac
    shift
done

# ------------------------------------------------------------------- #
#                       Default settings                              #
# ------------------------------------------------------------------- #

if [[ ${FLAGS[default]} -eq 1 ]]; then
    FLAGS[bin]=1
fi

# ------------------------------------------------------------------- #
#                        Validation                                   #
# ------------------------------------------------------------------- #

# -n and -x are conflicting options
if [[ ${FLAGS[exec]} -eq 1 && ${FLAGS[no_exec]} -eq 1 ]]; then
    echo "Error: conflicting options '-x' and '-n'" >&2
    echo $HELP_MSG >&2
    exit 1
fi

# ------------------------------------------------------------------- #
#                        Main job                                     #
# ------------------------------------------------------------------- #

# If no <dir> arguments were given
if [[ $# -eq 0 ]]; then
    collect_trash .
else
    for dir in "$@"; do
            [[ -d "$dir" ]] && collect_trash "$dir"
    done
fi

# If collected any trash ->
[[ ${#TRASH[@]} -gt 0 ]] && remove_trash

exit 0
